\datos{color}{}{}

\section{Programación con MoveIt2-ROS2-Gazebo} \label{prog}
La integración entre MoveIt2, ROS2 y Gazebo constituye uno de los entornos
más completos para la programación, simulación y control de manipuladores
robóticos modernos. \\

MoveIt2 es el \textit{framework} de planificación de movimiento
más extendido en el ecosistema ROS2, proporcionando algoritmos avanzados de
cinemática, planificación de trayectorias, control y percepción \cite{moveit2}. \\ 

Por su parte, ROS2 actúa como la capa de comunicación distribuida que permite
la interacción entre nodos, servicios y acciones \cite{ros2_jazzy}, mientras que Gazebo
ofrece un entorno de simulación física realista para validar el comportamiento
del robot antes de su despliegue en \textit{hardware} real \cite{gazebo_harmonic}. \\

En el caso de manipuladores comerciales como los brazos de la familia \textit{xArm},
el fabricante proporciona paquetes ROS2 ya configurados, incluyendo descripciones
URDF/XACRO, controladores, modelos de Gazebo y configuraciones básicas de MoveIt2
\cite{xarm_ros2}. Esto permite que el usuario pueda comenzar a trabajar directamente
desde la interfaz gráfica de MoveIt2 en RVIZ \cite{rviz} o mediante nodos que invoquen los
servicios y acciones expuestos por MoveIt2, sin necesidad de realizar configuraciones
complejas adicionales. \\

En el robot real, la controladora del fabricante es la que implementa la dinámica
y el control de bajo nivel, siendo un componente cerrado e inalterable. Esto implica
que MoveIt2 únicamente envía trayectorias en forma de puntos de referencia
o comandos de posición y velocidad, mientras que la controladora se encarga de
ejecutar el movimiento de manera segura y estable. No obstante, en los apartados 
anteriores de la memoria se ha expuesto cómo se diseñan y crean estas controladoras. \\

En esta sección se va a introducir el funcionamiento de MoveIt2 y las trayectorias
y algoritmos que emplea, y la programación báscia mediante la interfaz gráfica 
y automatizada mediante un nodo de ROS2 en C++. \\

\subsection{Algoritmos de planificación y generación de trayectorias en MoveIt2}

MoveIt2 no solo calcula rutas geométricas en el espacio articular o cartesiano, 
sino que también aplica algoritmos de \textit{time-parameterization} para generar 
trayectorias dinámicamente ejecutables. Estos algoritmos transforman una ruta 
geométrica en una trayectoria suave que respeta límites de velocidad, aceleración 
y, en algunos casos, \textit{jerk}, que es la derivada de la aceleración con respecto
del tiempo y mide los cambios bruscos en la aceleración. A continuación se mencionan
los principales métodos utilizados por MoveIt2, quedando fuera del alcance de este 
proyecto su descripción detallada.

\subsubsection{Planificadores geométricos (\textit{OMPL})}

MoveIt2 utiliza la librería \textit{OMPL} (\textit{Open Motion Planning Library}) para generar rutas geométricas en el espacio de 
configuraciones, sin información 
temporal ni dinámica, por lo que para que el robot pueda ejecutarla es necesario aplicar un 
algoritmo de parametrización temporal. Entre los algoritmos más empleados 
para la planificación geométrica se encuentran:

\begin{itemize}
    \item \textit{RRTConnect}: planificador rápido basado en muestreo, muy usado por defecto.
    \item \textit{RRT\*}: versión óptima que minimiza la longitud de la trayectoria.
    \item \textit{PRM / PRM\*}: planificadores basados en grafos probabilísticos.
    \item \textit{KPIECE, BKPIECE}: planificadores basados en proyección. \\
\end{itemize} 

\subsubsection{Interpolación cartesiana}

Cuando se requiere que el efector final siga una trayectoria estricta en el espacio 
cartesiano (por ejemplo, líneas rectas o movimientos de inserción), MoveIt2 emplea 
interpolación lineal entre poses consecutivas. Esta técnica es útil en tareas de
soldadura, pulido o aplicación de adhesivos, ensamblaje o inserción de piezas. \\

La interpolación cartesiana genera una ruta suave en el espacio del efector final, 
pero nuevamente sin información temporal. \\

\subsubsection{Algoritmos de parametrización temporal}

Una vez generada la ruta geométrica, MoveIt2 aplica un algoritmo de 
\textit{time-parameterization} para obtener una trayectoria ejecutable. Los principales 
métodos disponibles son:

\begin{itemize}
    \item \textit{Iterative Parabolic Time Parameterization (IPTP)}:  
    algoritmo clásico que genera trayectorias con perfiles parabólicos de velocidad.  
    Garantiza continuidad en posición y velocidad, pero no en \textit{jerk}.

    \item \textit{Time-Optimal Trajectory Generation (TOTG)}:  
    algoritmo que calcula la trayectoria más rápida posible respetando límites de 
    velocidad y aceleración. Produce movimientos suaves y eficientes.

    \item \textit{Ruckig (jerk-limited)}:  
    opción moderna para generar trayectorias con 
    continuidad en posición, velocidad, aceleración y \textit{jerk}.  
    Es ideal para robots industriales y manipuladores sensibles a cambios bruscos.

    \item \textit{Splines cúbicos y quinticos}:  
    utilizados internamente para suavizar trayectorias y garantizar continuidad 
    en derivadas superiores. Los polinomios de quinto orden son comunes en robótica 
    por su suavidad y estabilidad.
\end{itemize}

En la mayoría de configuraciones por defecto, MoveIt2 emplea \textit{IPTP} o 
\textit{Ruckig}, dependiendo de la versión y del paquete del robot. \\

\subsubsection{Ejecución de la trayectoria}

Es importante remarcar que MoveIt2 no ejecuta la trayectoria.  
Su función termina cuando genera una secuencia de puntos temporizados. La ejecución 
real depende del motor físico de Gazebo en simulación o de la controladora del
fabricante en el robot real, que en robots comerciales como \textit{xArm}, la
controladora interna es la responsable 
de aplicar la dinámica, compensación de gravedad, control de torque y estabilidad, 
mientras que MoveIt2 solo envía referencias de posición o velocidad.


\subsection{Programación básica con la GUI de MoveIt2 en RVIZ}
Al arrancar RVIZ, MoveIt2 y Gazebo aparecen dos ventanas: RVIZ y Gazebo. En RVIZ 
se muestra una visualización del robot en color naranja, representando el estado 
o posición objetivo (\textit{goal}), es decir, al que se quiere llegar. Si se activa 
la casilla ``\textit{Query start state}'' se añade una tercera visualización en color
verde, posición de inicio, y si se desactiva ``\textit{Show robot visual}'' aparece 
una tercera visualización en color gris: la posición actual del robot en Gazebo. 
En la figura \ref{fig:gui1} se observan estas tres visualizaciones. Las posiciones 
iniciales y finales se pueden mover arrastrando las esfera ubicada en los correspondientes
efectores.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{Images/moveIt/gui1.png}
    \includegraphics[width=0.95\textwidth]{Images/moveIt/gui2.png}
    \caption{Visualizaciones real, inicial y final del robot en RVIZ.}
    \label{fig:gui1}
\end{figure}

\clearpage
Al pulsar el botón de ``\textit{Plan}'' en el panel de \textit{MotionPlanning} se 
genera la planificación desde la pose inicial a la final, pero al pulsar 
``\textit{Plan \& Execute}'' la trayectoria se recalcula para ejecutarse desde la 
posición actual, en color gris, figura \ref{fig:gui2}. Cuando finaliza la ejecución,
las posiciones inicial, actual y final coinciden.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{Images/moveIt/gui3.png}
    \includegraphics[width=0.95\textwidth]{Images/moveIt/gui4.png}
    \includegraphics[width=0.95\textwidth]{Images/moveIt/gui5.png}
    \caption{Planificación y ejecución de la trayectoria.}
    \label{fig:gui2}
\end{figure}

\clearpage
En la trayectoria del ejemplo no se han producido colisiones en las posiciones 
inicial ni final, pero si ocurriesen, para garantizar la seguridad y que son estados 
factibles es recomendable activa la casilla ``\textit{Collision Enabled}'', figura 
\ref{fig:gui3}. También se puede activar ``\textit{Collision-aware IK}'' para que la 
cinemática inversa sea consciente de las posiciones que generan colisiones.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Images/moveIt/gui6.png}
    \includegraphics[scale=0.5]{Images/moveIt/gui7.png}
    \includegraphics[scale=0.55]{Images/moveIt/gui8.png}
    \caption{Colisiones activadas.}
    \label{fig:gui3}
\end{figure}

Otra forma de mover las poses inicial y final es mediante el panel 
``\textit{Joints}'' del panel de \textit{MotionPlanning}, figura \ref{fig:gui4}, donde 
``\textit{Nullspace exploration} permite descubrir nuevas configuraciones que
mantienen la posición, diseñado para robots redundantes.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{Images/moveIt/gui9.png}
    \caption{Panel de \textit{joints}.}
    \label{fig:gui4}
\end{figure}

Si se activa ``\textit{Show trail}'' se muestra el movimiento de la trayectoria 
planificada, figura \ref{fig:gui5}. Para ver cada punto de paso generado, hay que 
activar el ``\textit{Trajectory Slider}'' y deshabilitar el movimiento anterior, 
figura \ref{fig:gui6}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.285]{Images/moveIt/gui10.png}
    \caption{Movimiento de la trayectoria planificada.}
    \label{fig:gui5}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{Images/moveIt/gui11.png}
    \includegraphics[scale=0.285]{Images/moveIt/gui12.png}
    \caption{Visualización de puntos de paso.}
    \label{fig:gui6}
\end{figure}

\clearpage
Si se activa la casilla de ``\textit{Cartesian Path}'' en el cuadro ``\textit{Options}''
del panel de \textit{MotionPlanning} se genera una trayectoria cartesiana, figura 
\ref{fig:gui7}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.285]{Images/moveIt/gui13.png}
    \caption{Trayectoria cartesiana.}
    \label{fig:gui7}
\end{figure}

Por último, se puede controlar la velocidad y aceleración, entre otros parámetros, 
mediante el cuadro ``\textit{Options}'' del panel de \textit{MotionPlanning}.

\subsection{Programación básica con un nodo en C++}

MoveIt2 expone una serie de servicios y acciones en ROS2 que permiten
interactuar con el planificador de movimiento desde nodos externos. Estos
\textit{endpoints} constituyen la interfaz principal para solicitar planes, ejecutar
trayectorias, obtener información del estado cinemático o consultar la escena
de planificación. En particular, el componente \texttt{move\_group} actúa como
servidor central y ofrece una acción denominada \texttt{/move\_action}, basada
en el tipo \texttt{moveit\_msgs/action/MoveGroup}. Esta acción permite enviar
objetivos de movimiento tanto articulares como cartesianos, junto con
restricciones, factores de escalado de velocidad y aceleración, y otros
parámetros de planificación.

Entre los servicios y acciones más relevantes que expone MoveIt2 se encuentran:

\begin{itemize}
    \item Acción \texttt{/move\_action}: interfaz principal para solicitar
    planes y ejecutar movimientos mediante el tipo \texttt{MoveGroup}. Permite
    definir objetivos articulares, pose targets, rutas cartesianas y restricciones
    complejas.
    \item Servicio \texttt{/compute\_cartesian\_path}: genera rutas
    cartesianas interpoladas directamente en el espacio del efector final.
    \item Servicio \texttt{/get\_planning\_scene}: devuelve la escena de
    planificación actual, incluyendo obstáculos, colisiones y estado del robot.
    \item Servicio \texttt{/query\_planner\_interfaces}: lista los
    planificadores disponibles (OMPL, CHOMP, STOMP, etc.).
    \item Acción \texttt{/execute\_trajectory}: ejecuta una trayectoria ya
    planificada sin volver a calcularla.
\end{itemize}

En este trabajo se utiliza la acción \texttt{/move\_action}, que es la forma más
directa de solicitar a MoveIt2 que planifique y ejecute un movimiento. Para ello
se implementa un nodo en C++ que actúa como \textit{action client}. El nodo se
conecta al servidor de acciones de MoveIt2, construye un objetivo articular y
espera a que la acción finalice antes de continuar con la secuencia. \\

El nodo desarrollado se muestra en el código \ref{lst:node_moveit} y en la figura
\ref{fig:gazebo} se observa la ejecución de la trayectoria en Gazebo.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.24]{Images/moveIt/gz.png}
    \includegraphics[scale=0.24]{Images/moveIt/gz2.png}
    \includegraphics[scale=0.24]{Images/moveIt/gz3.png}
    \caption{Movimiento del robot en Gazebo.}
    \label{fig:gazebo}
\end{figure}
