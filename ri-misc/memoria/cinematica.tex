\datos{color}{}{}

\section{Estudio cinemático}
El fabricante proporciona los parámetros clásicos y modificados de Denavit-Hartenberg en el manual del usuario. En las 
siguientes secciones se van a estudiar dichos parámetros.

\subsection{Cinemática directa}
\subsubsection{Parámetros de Denavit-Hartenberg} \label{classDH}
En la figura \ref{fig:dh} se presentan los parámetros clásicos de Denavit-Hartenberg \cite{barrientos2007fundamentos} proporcionados por el fabricante, con 
\[
a_2 = \sqrt{284.5^2 + 53.5^2} = 289.48866
\]
\[
T_{2,\text{offset}} = -\arctan\left(\frac{284.5}{53.5}\right) = -1.3849179 \; (-79.34995^\circ);\;
T_{3,\text{offset}} = -T_{2,\text{offset}}.
\]

\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.45]{Images/cinematica/dh.png}
    \caption{Parámetros clásicos Denavit-Hartenberg. Fuente: \cite{ufactory_xarm_manual}.}
    \label{fig:dh}
\end{figure}

\newpage
Para alcanzar los sitemas $2$ y $3$ se introduce un \textit{offset} dado que en la imagen la tercera articulación no están 
representada en el cero, por lo que el \textit{offset} es el ángulo de compensación de la articulación desde la posición
matemática cero hasta la posición mecánica cero que se muestra en la imagen. Esto se debe a que si se colocase en el cero, 
en la imagen quedaría detrás de otros eslabones y no se visualizaría. En otras palabras, el \textit{offset} angular corrige la
orientación sin necesidad de modificar el ángulo $\theta$ de la articulación y se suma directamente a $\theta_i$.\\

Además, a partir del análisis de la figura \ref{fig:dh} se observa la particularidad en la ubicación del origen de algunos sistemas,
como $3$ y $4$. Esta elección, aunque poco convencional, facilita el cálculo de los parámetros al estar directamente fundamentada en las dimensiones 
geométricas del robot. De este modo, el parámetro $d_4$ coincide con la distancia medida que aparece en la imagen de los 
parámetros de tamaño. Este hecho se repite para el resto de de parámetros longitudinales $d_1$, $a_3$, $a_5$, $d_6$. \\

La secuencia de transformaciones \cite{corke1996} y la matriz de transformación homogénea \cite{barrientos2007fundamentos}
asociada a dichas transformaciones se presentan en las ecuaciones \ref{eq:dh-seq} y \ref{eq:dh-a}:

\begin{equation}
{^{i-1}A_{i}} = 
\textbf{R}_Z(\theta^*_i = \theta_i + \text{\textit{offset}$_i$})\,
\textbf{T}_Z(d_i)\,
\textbf{T}_X(a_{i})\,
\textbf{R}_X(\alpha_{i})
\label{eq:dh-seq}
\end{equation}

\begin{equation}
{}^{i-1}\mathbf{A}_i =
\begin{bmatrix}
\cos\theta^*_i                  & -\sin\theta^*_i \cos\alpha_i     &  \sin\theta^*_i \sin\alpha_i     & a_i \cos\theta^*_i          \\
\sin\theta^*_i                  &  \cos\theta_i \cos\alpha_i     & -\cos\theta^*_i \sin\alpha_i     & a_i \sin\theta^*_i          \\
0                             &  \sin\alpha_i                  &  \cos\alpha_i                  & d_i                       \\
0                             &  0                             &  0                             & 1
\end{bmatrix}
\label{eq:dh-a}
\end{equation} \\

Se calculan a continuación las matrices de transformación del robot \textit{UFactory xArm 6} utilizando
los parámetros clásicos de Denavit-Hartenberg:
\[
A_1 =
\begin{bmatrix}
C(q_1) & 0 & -S(q_1) & 0 \\
S(q_1) & 0 & C(q_1) & 0 \\
0 & -1 & 0 & 267 \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

\[
A_2 =
\begin{bmatrix}
C(q_2+\text{offset}_2) & -S(q_2+\text{offset}_2) & 0 & a_2\,C(q_2+\text{offset}_2) \\
S(q_2+\text{offset}_2) & C(q_2+\text{offset}_2) & 0 & a_2\,S(q_2+\text{offset}_2) \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\quad a_2=289.48866
\]

\[
A_3 =
\begin{bmatrix}
C(q_3+\text{offset}_3) & 0 & -S(q_3+\text{offset}_3) & a_3\,C(q_3+\text{offset}_3) \\
S(q_3+\text{offset}_3) & 0 & C(q_3+\text{offset}_3) & a_3\,S(q_3+\text{offset}_3) \\
0 & -1 & 0 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\quad a_3=77.5
\]

\[
A_4 =
\begin{bmatrix}
C(q_4) & 0 & S(q_4) & 0 \\
S(q_4) & 0 & -C(q_4) & 0 \\
0 & 1 & 0 & 342.5 \\
0 & 0 & 0 & 1
\end{bmatrix}
,\;
A_5 =
\begin{bmatrix}
C(q_5) & 0 & -S(q_5) & a_5\,C(q_5) \\
S(q_5) & 0 & C(q_5) & a_5\,S(q_5) \\
0 & -1 & 0 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\quad a_5=76
\]

\[
A_6 =
\begin{bmatrix}
C(q_6) & -S(q_6) & 0 & 0 \\
S(q_6) & C(q_6) & 0 & 0 \\
0 & 0 & 1 & 97 \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

Siendo la transformación total:
\[
T_0^{\,6}(q) = A_1(q_1)\;A_2(q_2+\text{offset}_2)\;A_3(q_3+\text{offset}_3)\;A_4(q_4)\;A_5(q_5)\;A_6(q_6)
\] \\

Podemos calcular y comprobar el resultado en \textit{Matlab} \cite{matlabonline2025} y la \textit{toolbox} de
Peter Corke \cite{corke_robotics_toolbox}:
\lstinputlisting[
    caption={Código Matlab para la cinemática directa con parámetros DH clásicos.},
    label={lst:dh},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/dh.m}
\lstinputlisting[
    caption={Salida numérica de la cinemática directa DH clásica.},
    label={lst:dh_salida},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/dh_salida.txt}

\clearpage
\subsubsection{Parámetros modificados de Denavit-Hartenberg} \label{sec:dh-mod}
El método clásico de Denavit-Hartenberg, propuesto en 1955, presentaba ciertas limitaciones en la colocación de los sistemas
de referencia, especialmente cuando dos ejes consecutivos eran paralelos. En estos casos podían aparecer ambigüedades en la
definición de los parámetros y problemas numéricos en las matrices de transformación. \\

Para superar estas dificultades John J. Craig introdujo el método modificado de Denavit-Hartenberg o convención de Craig
\cite{craig1986, paul1986}, que redefine las transformaciones con respecto al sistema $i$ en lugar de hacerlo respecto al sistema $i-1$. El método modificado mantiene los
cuatro parámetros $\theta_i, d_i, a_i, \alpha_i$, pero cambia la referencia de los ejes lo que hace más intuitiva la
asignación de marcos. El nuevo procedimiento para asignar los sistemas de referencia se resume en los siguientes pasos:
\begin{enumerate}
    \item Identificar los ejes de las articulaciones.
    \item Considerar dos ejes consecutivos ($i$ y $i+1$) e identificar la perpendicular común entre ellos, o bien el punto de intersección.
          En dicho punto de intersección, o en el punto donde la perpendicular común corta al eje $i$, se asigna el origen del sistema de enlace.
    \item Asignar el eje $Z_i$ apuntando a lo largo del eje de la articulación $i$.
    \item Asignar el eje $X_i$ apuntando a lo largo de la perpendicular común. Si los ejes se intersectan, se asigna $X_i$ como normal al plano que contiene ambos ejes.
    \item Asignar el eje $Y_i$ de manera que se complete un sistema de coordenadas con la regla de la mano derecha (sistema dextrógiro).
    \item Asignar el sistema $\{0\}$ coincidiendo con $\{1\}$ cuando la primera variable articular sea cero. Para el sistema $\{N\}$, elegir libremente la posición del origen y la dirección de $X_N$, procurando que el mayor número posible de parámetros de enlace se anulen.
\end{enumerate}

Consecuentemente, la secuencia de transformaciones \cite{corke1996} y la matriz de transformación homogénea
asociada a dichas transformaciones se presentan en las ecuaciones \ref{eq:dh_mod-seq} y \ref{eq:dh_mod-a}:
\begin{equation}
{^{i-1}\bar{A}_{i}} = 
\textbf{R}_X(\alpha_{i-1})\,
\textbf{T}_X(a_{i-1})\,
\textbf{R}_Z(\theta_i)
\textbf{T}_Z(d_i)\,
\label{eq:dh_mod-seq}
\end{equation}

\begin{equation}
{}^{i-1}\mathbf{A}_i = 
\begin{bmatrix}
\cos\theta_i                  & -\sin\theta_i &  0 & a_{i-1}      \\
\sin\theta_i \cos\alpha_{i-1}                  &  \cos\theta_i \cos\alpha_{i-1} & -\sin\alpha_{i-1} & -d_i \sin\alpha_{i-1}      \\
\sin\theta_i \sin\alpha_{i-1}              &  \sin\alpha_{i-1} \cos\theta_i              &  \cos\alpha_{i-1}              & d_i \cos\alpha_{i-1}                      \\
0                             &  0                             &  0                             & 1
\end{bmatrix}
\label{eq:dh_mod-a}
\end{equation} \\

Esta convención ofrece ventajas como la asignación única y consistente de marcos a cada eslabón porque simplifica la 
implementación computacional y la integración con modelos de diseño asistido por computadora (CAD), donde se prefieren
coordenadas locales de eslabón \cite{corke1996}. Además, facilita los cálculos recursivos de cinemática, Jacobianos
y dinámica, evitando las ambigüedades de colocación presentes en el método estándar y es la notación más clara
y transparente para el análisis mecánico. \\

\newpage
En la figura \ref{fig:dh_mod} se presentan los parámetros modificados de Denavit-Hartenberg proporcionados por el fabricante, con 
\[
a_2 = \sqrt{284.5^2 + 53.5^2} = 289.48866
\]
\[
T_{2,\text{offset}} = -\arctan\left(\frac{284.5}{53.5}\right) = -1.3849179 \; (-79.34995^\circ)
\]
\[
T_{3,\text{offset}} = -T_{2,\text{offset}} = 1.3849179 \; (79.34995^\circ).
\]
\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.45]{Images/cinematica/dh_mod.png}
    \caption{Parámetros modificados Denavit-Hartenberg. Fuente: \cite{ufactory_xarm_manual}.}
    \label{fig:dh_mod}
\end{figure}

Al igual que con los parámetros clásicos, sección \ref{classDH}, para alcanzar los sitemas $2$ y $3$ se introduce un \textit{offset} dado que en la imagen la tercera articulación no están 
representada en el cero y se observa la particularidad en la ubicación del origen de algunos sistemas,
como $3$ y $4$, que facilita el cálculo de los parámetros al estar directamente fundamentada en las dimensiones 
geométricas del robot. \\

Se calculan a continuación las matrices de transformación del robot \textit{UFactory xArm 6} utilizando
los parámetros modificados de Denavit-Hartenberg:

\[
A_1 =
\begin{bmatrix}
C(q_1) & -S(q_1) & 0 & 0 \\
S(q_1) & C(q_1) & 0 & 0 \\
0 & 0 & 1 & d_1 \\
0 & 0 & 0 & 1
\end{bmatrix}
\quad d_1 = 267
\]

\[
A_2 =
\begin{bmatrix}
C(q_2+T2_{\text{offset}}) & -S(q_2+T2_{\text{offset}}) & 0 & 0 \\
0 & 0 & 1 & 0 \\
-\,S(q_2+T2_{\text{offset}}) & -\,C(q_2+T2_{\text{offset}}) & 0 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

\[
A_3 =
\begin{bmatrix}
C(q_3+T3_{\text{offset}}) & -S(q_3+T3_{\text{offset}}) & 0 & a_2 \\
S(q_3+T3_{\text{offset}}) & C(q_3+T3_{\text{offset}}) & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\quad a_2 = 289.48866
\]

\[
A_4 =
\begin{bmatrix}
C(q_4) & -S(q_4) & 0 & a_3 \\
0 & 0 & 1 & d_4 \\
-\,S(q_4) & -\,C(q_4) & 0 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\quad a_3 = 77.5,\; d_4 = 342.5
\]

\[
A_5 =
\begin{bmatrix}
C(q_5) & 0 & S(q_5) & 0 \\
S(q_5) & 0 & -C(q_5) & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

\[
A_6 =
\begin{bmatrix}
C(q_6) & -S(q_6) & 0 & a_5 \\
0 & 0 & 1 & d_6 \\
-\,S(q_6) & -\,C(q_6) & 0 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\quad a_5 = 76,\; d_6 = 97
\] \\

Siendo la transformación total:
\[
T_0^{\,6}(q) = A_1(q_1)\;A_2(q_2+T2_{\text{offset}})\;A_3(q_3+T3_{\text{offset}})\;A_4(q_4)\;A_5(q_5)\;A_6(q_6)
\]\\

\newpage
Podemos calcular y comprobar el resultado en \textit{Matlab} \cite{matlabonline2025} y la \textit{toolbox} de
Peter Corke \cite{corke_robotics_toolbox}:
\lstinputlisting[
    caption={Código Matlab para la cinemática directa con parámetros DH modificados.},
    label={lst:dh_mod},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/dh_mod.m}
\lstinputlisting[
    caption={Salida numérica de la cinemática directa DH modificada.},
    label={lst:dh_mod_salida},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/dh_mod_salida.txt}

\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.9]{Images/cinematica/modelado2.png}
    \caption{Modelado del \textit{UFactory xArm6} en \textit{Matlab} con parámetros DH modificados.}
    \label{fig:dh}
\end{figure}

\clearpage
\subsection{Cinemática inversa}
Tanto para los parámetros clásicos como para los modificados de Denavit-Hartenberg
las ecuaciones obtenidas a resolver son geométricamente iguales, y obtienen los mismos 
resultados, pero las ventajas de la convención modificada suelen facilitar su resolución.
Por ello, se estudia la cinematica inversa sobre los parámetros modificados. \\

Cuando la muñeca es esférica, es decir, los ejes de las articulaciones 4, 5 y 6 se cortan en 
único punto o $a_4 = a_5 = a_6 = 0, d_5 = d_6 = 0$, se puede aplicar el método de desacoplo cinemático
\cite{barrientos2007fundamentos}. Sin embargo, esta propiedad no se cumple en el robot
\textit{UFactory xArm6}, ya que la posición y orientación depende de todas las articulaciones.
Por tanto, no existe separación natural entre el brazo y la muñeca y la cinemática inversa 
se vuelve mucho más compleja porque no existe en forma cerrada. \\

Consecuentemente, este problema no puede resolverse analíticamente y tiene que ser resuelto 
con métodos numéricos iterativos como el inverso, pseudo-inverso y transpuesto del Jacobiano, 
Newton–Raphson o Levenberg–Marquardt, entre otros, utilizando las 12 ecuaciones de la matriz de 
transformación $T_0^{\,6}$. Estos métodos aproximan la solución
mediante iteraciones sucesivas, minimizando el error entre la posición y orientación deseada y 
la alcanzada alcanzada por el robot.\\

El repositorio oficial del fabricante \cite{xarm_ros2} utiliza \textit{MoveIt 2} \cite{moveit2}, que 
resuelve la cinemática inversa mediante Jacobiano pseudo-inverso y métodos iterativos de tipo 
Newton–Raphson.

De la matriz de transformación obtenida en el código \ref{lst:dh_mod},
$T_0^{\,6} = \begin{bmatrix}
r_{11} & r_{12} & r_{13} & p_x \\
r_{21} & r_{22} & r_{23} & p_y \\
r_{31} & r_{32} & r_{33} & p_z \\
0      & 0      & 0      & 1
\end{bmatrix}
$, se obtienen las 
siguientes ecuaciones de posición y orientación:

\[
\begin{aligned}
p_x &= 
\cos(q_1)\cos(T2_{\text{offset}} + T3_{\text{offset}} + q_2 + q_3)
\left( 76\cos q_4 \cos q_5 - 97\cos q_4 \sin q_5 + \frac{155}{2} \right) \\
&\quad + a_2 \cos(q_1)\cos(T2_{\text{offset}} + q_2) \\
&\quad - \cos(q_1)\sin(T2_{\text{offset}} + T3_{\text{offset}} + q_2 + q_3)
\left( 97\cos q_5 + 76\sin q_5 + \frac{685}{2} \right) \\
&\quad + \sin(q_1)\sin(q_4)\left( 76\cos q_5 - 97\sin q_5 \right),
\end{aligned}
\] \\

\[
\begin{aligned}
p_y &= 
\sin(q_1)\cos(T2_{\text{offset}} + T3_{\text{offset}} + q_2 + q_3)
\left( 76\cos q_4 \cos q_5 - 97\cos q_4 \sin q_5 + \frac{155}{2} \right) \\
&\quad + a_2 \sin(q_1)\cos(T2_{\text{offset}} + q_2) \\
&\quad - \sin(q_1)\sin(T2_{\text{offset}} + T3_{\text{offset}} + q_2 + q_3)
\left( 97\cos q_5 + 76\sin q_5 + \frac{685}{2} \right) \\
&\quad - \cos(q_1)\sin(q_4)\left( 76\cos q_5 - 97\sin q_5 \right),
\end{aligned}
\] \\


\[
\begin{aligned}
p_z &= 
267 - a_2 \sin(T2_{\text{offset}} + q_2) \\
&\quad - \cos(T2_{\text{offset}} + T3_{\text{offset}} + q_2 + q_3)
\left( 97\cos q_5 + 76\sin q_5 + \frac{685}{2} \right) \\
&\quad - \sin(T2_{\text{offset}} + T3_{\text{offset}} + q_2 + q_3)
\left( 76\cos q_4 \cos q_5 - 97\cos q_4 \sin q_5 + \frac{155}{2} \right).
\end{aligned}
\] \\

Sea $\phi = T2_{\text{offset}} + T3_{\text{offset}} + q_2 + q_3$, 
de modo que las expresiones de la matriz de rotación se simplifican.

\[
\begin{aligned}
& r_{11} =
\sin q_1 \left(\cos q_4 \sin q_6 + \cos q_5 \cos q_6 \sin q_4\right)
- \cos q_1 \cos\phi \left(\sin q_4 \sin q_6 - \cos q_4 \cos q_5 \cos q_6\right) \\
&\quad - \cos q_1 \sin\phi \,\cos q_6 \sin q_5
\end{aligned}
\]

\[
\begin{aligned}
& r_{12} = 
\sin q_1 \left(\cos q_4 \cos q_6 - \cos q_5 \sin q_4 \sin q_6\right) 
- \cos q_1 \cos\phi \left(\cos q_6 \sin q_4 + \cos q_4 \cos q_5 \sin q_6\right) \\
&\quad + \cos q_1 \sin\phi \,\sin q_5 \sin q_6 \end{aligned} \]

\[
\begin{aligned}
r_{13} = 
-\sin q_1 \sin q_4 \sin q_5
- \cos q_1 \sin\phi \,\cos q_5
- \cos q_1 \cos\phi \,\cos q_4 \sin q_5
\end{aligned} \]

\[
\begin{aligned}
& r_{21} =
-\cos q_1 \left(\cos q_4 \sin q_6 + \cos q_5 \cos q_6 \sin q_4\right)
- \sin q_1 \cos\phi \left(\sin q_4 \sin q_6 - \cos q_4 \cos q_5 \cos q_6\right) \\
&\quad - \sin q_1 \sin\phi \,\cos q_6 \sin q_5 \end{aligned}\]

\[
\begin{aligned}
& r_{22} =
\sin q_1 \sin\phi \,\sin q_5 \sin q_6
- \sin q_1 \cos\phi \left(\cos q_6 \sin q_4 + \cos q_4 \cos q_5 \sin q_6\right) \\
&\quad - \cos q_1 \left(\cos q_4 \cos q_6 - \cos q_5 \sin q_4 \sin q_6\right) \end{aligned}\]

\[ \begin{aligned}
r_{23} =
\cos q_1 \sin q_4 \sin q_5
- \sin q_1 \sin\phi \,\cos q_5
- \sin q_1 \cos\phi \,\cos q_4 \sin q_5
\end{aligned}
\]

\[
\begin{aligned}
r_{31} &=
\sin\phi \left(\sin q_4 \sin q_6 - \cos q_4 \cos q_5 \cos q_6\right)
- \cos\phi \,\cos q_6 \sin q_5 \end{aligned} \]

\[ \begin{aligned}
r_{32} &=
\sin\phi \left(\cos q_6 \sin q_4 + \cos q_4 \cos q_5 \sin q_6\right)
+ \cos\phi \,\sin q_5 \sin q_6 \end{aligned} \]

\[ \begin{aligned}
r_{33} &=
\sin\phi \,\cos q_4 \sin q_5
- \cos\phi \,\cos q_5
\end{aligned}
\] \\


% https://www.youtube.com/watch?v=mxf5H84L0Wo

\newpage
Estas ecuaciones se han obtenido con la ayuda de \textit{Matlab} \cite{matlabonline2025} y la
\textit{toolbox} de Peter Corke \cite{corke_robotics_toolbox}:
\lstinputlisting[
    caption={Código Matlab para obtener las ecuaciones de posición y orientación con parámetros DH modificados.},
    label={lst:ik},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/ik.m}

\clearpage
\subsubsection{Pseudoinversa del Jacobiano y Newton--Raphson}

Como se expone en \cite{barrientos2007fundamentos}, la relación entre las velocidades
articulares y la velocidad del efector final viene dada por



\[
\dot{x} = J(q)\,\dot{q},
\]



donde $J(q)$ es el Jacobiano geométrico del manipulador. Para invertir esta relación y
obtener un incremento articular a partir de un desplazamiento cartesiano, se emplea la
pseudoinversa del Jacobiano,



\[
\dot{q} = J^{\dagger}(q)\,\dot{x},
\qquad
J^{\dagger} = (J^\top J)^{-1} J^\top,
\]



válida cuando el Jacobiano es de rango completo. Este operador permite calcular un
incremento articular que minimiza en norma cuadrática el error cartesiano, incluso en
configuraciones próximas a singularidades o en robots redundantes.

Este mismo principio se aplica a la resolución numérica de la cinemática inversa. El
objetivo consiste en encontrar un vector articular $q$ tal que



\[
f(q) = x_d,
\]



siendo $f(q)$ la cinemática directa y $x_d$ la posición y orientación deseadas del
efector final. Definiendo el error cartesiano como



\[
e = x_d - f(q),
\]



y linealizando la cinemática directa alrededor de la configuración actual,



\[
f(q + \Delta q) \approx f(q) + J(q)\,\Delta q,
\]



se obtiene la actualización iterativa característica del método de Newton--Raphson \cite{siciliano2009robotics}:



\[
q_{k+1} = q_k + J^{\dagger}(q_k)\,(x_d - f(q_k)).
\]



En esta expresión, $J^{\dagger}(q_k)$ actúa como una inversa generalizada del Jacobiano,
permitiendo calcular un incremento articular coherente incluso cuando $J(q_k)$ no es
cuadrado o se encuentra próximo a una singularidad. Este procedimiento converge de forma
eficiente siempre que la estimación inicial sea adecuada, y constituye uno de los métodos
numéricos más empleados para resolver la cinemática inversa en manipuladores sin solución
analítica cerrada. \\

\subsubsection*{Ejemplo sencillo de Newton--Raphson a mano}

Para ilustrar el método de Newton--Raphson, se considera un manipulador
unidimensional con una sola articulación \(q \in \mathbb{R}\), cuya cinemática directa
viene dada por
\[
f(q) = q^2.
\]
El objetivo es encontrar el valor de \(q\) tal que la posición cartesiana del efector
final coincida con una posición deseada \(x_d\). En este ejemplo se fija
\[
x_d = 4.
\]
El problema de cinemática inversa se escribe entonces como
\[
f(q) = x_d
\quad\Longleftrightarrow\quad
q^2 = 4.
\]

Siguiendo la estructura anterior, se define el error cartesiano como
\[
e(q) = x_d - f(q) = 4 - q^2.
\]

En este caso, como se trata de un problema unidimensional, el Jacobiano geométrico se
reduce a la derivada de \(f(q)\) con respecto a \(q\):
\[
J(q) = \frac{\partial f}{\partial q} = 2q.
\]
Para \(J(q) \neq 0\), la pseudoinversa de un escalar coincide con su inversa
\[
J^{\dagger}(q) = \frac{1}{J(q)} = \frac{1}{2q}.
\]

Aplicando el esquema iterativo de Newton--Raphson para la cinemática inversa, se obtiene
\[
q_{k+1} = q_k + J^{\dagger}(q_k)\,\bigl(x_d - f(q_k)\bigr).
\]
Sustituyendo las expresiones de \(f(q)\), \(x_d\) y \(J^{\dagger}(q)\),
\[
q_{k+1} = q_k + \frac{1}{2q_k}\,\bigl(4 - q_k^2\bigr).
\]

\subsubsection*{Cálculo iterativo a mano}

Se elige, por ejemplo, una estimación inicial
\[
q_0 = 1.
\]
A partir de esta estimación, se calcula paso a paso:

\paragraph{Iteración 1}
\[
f(q_0) = f(1) = 1^2 = 1,
\]
\[
x_d - f(q_0) = 4 - 1 = 3,
\]
\[
J(q_0) = 2q_0 = 2\cdot 1 = 2,
\qquad
J^{\dagger}(q_0) = \frac{1}{2}.
\]
Por tanto,
\[
q_1 = q_0 + J^{\dagger}(q_0)\,\bigl(x_d - f(q_0)\bigr)
    = 1 + \frac{1}{2}\cdot 3
    = 1 + 1.5
    = 2.5.
\]

\paragraph{Iteración 2}
\[
f(q_1) = f(2.5) = (2.5)^2 = 6.25,
\]
\[
x_d - f(q_1) = 4 - 6.25 = -2.25,
\]
\[
J(q_1) = 2q_1 = 2\cdot 2.5 = 5,
\qquad
J^{\dagger}(q_1) = \frac{1}{5}.
\]
Así,
\[
q_2 = q_1 + J^{\dagger}(q_1)\,\bigl(x_d - f(q_1)\bigr)
    = 2.5 + \frac{1}{5}\cdot(-2.25)
    = 2.5 - 0.45
    = 2.05.
\]

\paragraph{Iteración 3}
\[
f(q_2) = f(2.05) = (2.05)^2 \approx 4.2025,
\]
\[
x_d - f(q_2) \approx 4 - 4.2025 = -0.2025,
\]
\[
J(q_2) = 2q_2 = 2\cdot 2.05 = 4.10,
\qquad
J^{\dagger}(q_2) = \frac{1}{4.10}.
\]
La siguiente actualización es
\[
q_3 = q_2 + J^{\dagger}(q_2)\,\bigl(x_d - f(q_2)\bigr)
    \approx 2.05 + \frac{1}{4.10}\cdot(-0.2025)
    \approx 2.05 - 0.0494
    \approx 2.0006.
\]

Después de unas pocas iteraciones, el valor de \(q_k\) converge rápidamente hacia
\[
q^\star \approx 2,
\]
que es una de las soluciones exactas de la ecuación \(q^2 = 4\). En este ejemplo tan
simple, el Jacobiano es un escalar y su pseudoinversa coincide con la inversa, de modo
que la actualización de Newton--Raphson se interpreta exactamente como en el caso
general:
\[
q_{k+1} = q_k + J^{\dagger}(q_k)\,(x_d - f(q_k)),
\]
pero aplicada a una cinemática directa escalar y sencilla. \\


\subsubsection{Cálculo de cinemática inversa para \textit{UFactory xArm6}}

De la tabla \ref{tab:actuators} se conoce que las articulaciones del robot presentan límites 
físicos de movimiento, por lo que el método iterativo de Newton–Raphson debe modificarse para 
garantizar que las soluciones obtenidas se mantengan dentro de dichos rangos. Este problema es
bien conocido en robótica y suele abordarse mediante técnicas de \textit{joint limit avoidance} 
\cite{siciliano2009robotics, nakamura1991advanced}, que introducen un término adicional en la
actualización de las articulaciones para alejar la solución de los límites articulares. \\

En lugar de aplicar un recorte directo de las articulaciones (\textit{clamping}), que puede 
bloquear la convergencia cuando la solución se encuentra cerca de un límite, se define una 
función de coste que penaliza la proximidad a los extremos del rango articular:
\[
H(q) = \sum_{i=1}^{6} 
\left( \frac{q_i - q_{i,\text{mid}}}{q_{i,\text{max}} - q_{i,\text{min}}} \right)^2,
\]
donde $q_{i,\text{min}}$ y $q_{i,\text{max}}$ son los límites articulares y 
$q_{i,\text{mid}} = (q_{i,\text{min}} + q_{i,\text{max}})/2$ es el punto medio del rango.  
El gradiente de esta función,

\[
\nabla H_i = 
2\,\frac{q_i - q_{i,\text{mid}}}{(q_{i,\text{max}} - q_{i,\text{min}})^2},
\]
indica la dirección en la que cada articulación debe desplazarse para alejarse de los límites.  
Este gradiente se incorpora directamente en la ecuación iterativa del método de Newton–Raphson, 
modificando la actualización clásica $\Delta q = J^{+}(q_k)\, e(q_k)$, para incluir un término de
penalización:
\[
\Delta q = J^{+}(q_k)\, e(q_k) \;-\; K\, \nabla H(q_k),
\]
donde $K$ es un coeficiente positivo que controla la intensidad de la penalización.  
Este enfoque permite que el algoritmo reduzca el error de posición garantizando que las posiciones 
articulares obtenidas son factibles y se utiliza ampliamente en control redundante y cinemática
inversa con restricciones \cite{buss2004selectively}. \\

Además, para mejorar la estabilidad numérica cerca de singularidades, se emplea la variante 
amortiguada del método, conocida como \textit{Damped Least Squares} (DLS) o método de Levenberg–Marquardt 
\cite{wampler1986manipulator, nakamura1991advanced}. En este caso, la pseudoinversa se sustituye por:
\[
\Delta q = 
J^\top (J J^\top + \lambda^2 I)^{-1} e(q_k) \;-\; K\, \nabla H(q_k),
\]
donde $\lambda$ es un factor de amortiguación que evita que el Jacobiano se acerque a una singularidad
o configuración geométricamente desfavorable.\\

La combinación de penalización suave y amortiguación
permite obtener soluciones de cinemática inversa que respetan los límites articulares, evitan configuraciones cercanas a singularidades y mantienen la 
convergencia del método incluso en zonas estrechas del espacio de trabajo. \\

A continuación se expone la porción de código de \textit{Matlab} \cite{matlabonline2025} y la \textit{Robotics Toolbox} de
Peter Corke \cite{corke_robotics_toolbox} con la que se ha programado la 
cinemática inversa para el \textit{UFactory xArm6}:
\lstinputlisting[
    caption={Cálculo de la cinemática inversa del robot \textit{UFactory xArm6}.},
    label={lst:ik_nr},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/ik_nr.m}

\lstinputlisting[
    caption={Salida del cálculo de la cinemática inversa del robot \textit{UFactory xArm6}.},
    label={lst:ik_nr},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/ik_nr_salida.m}


\newpage

\subsection{Cinemática diferencial y Jacobiano}
Tal y como se expone en el apartado anterior, la cinemática diferencial describe la relación entre las velocidades articulares $\dot{q}$ y la
velocidad del efector final $\dot{x}$. Esta relación viene dada por \[ \dot{x} = J(q)\,\dot{q}, \]
donde $J(q)$ es el Jacobiano geométrico del manipulador. El Jacobiano recoge cómo las variaciones
infinitesimales de las articulaciones se traducen en variaciones infinitesimales en el espacio
cartesiano, y constituye la herramienta fundamental para analizar velocidades, singularidades y
la cinemática inversa diferencial. Cuando se desea obtener un incremento articular a partir de un
desplazamiento cartesiano, es necesario invertir esta relación. Sin embargo, el Jacobiano no siempre 
es cuadrado ni invertible, por lo que se recurre a una inversa generalizada, como la pseudoinversa,
que permite obtener soluciones en mínimos cuadrados incluso en configuraciones próximas a 
singularidades. \\

A partir de la transformación homogénea total
\[ T_0^{\,6}(q) = A_1(q_1)\;A_2(q_2+T2_{\text{offset}})\;A_3(q_3+T3_{\text{offset}})
\;A_4(q_4)\;A_5(q_5)\;A_6(q_6), \] 
 
se pueden calcular las matrices de rotación y vectores de posición necesarios para construir
el Jacobiano y para calcular las velocidades lineales y angulares de las articulaciones y del efector.
Dado que la matriz de transformación resultante es una expresión grande, su manejo 
manual simbólico resulta muy tedioso, por lo que se ha calculado con ayuda de \textit{Matlab} 
\cite{matlabonline2025} y la \textit{Robotics Toolbox} de Peter Corke \cite{corke_robotics_toolbox}: \\
\lstinputlisting[
    caption={Cálculo de la cinemática diferencial y Jacobiano mediante parámetros DH modificados.},
    label={lst:jac},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/jac.m}

\newpage
\subsection{Generación de trayectorias}

La generación de trayectorias se implementa mediante
el planificador de \textit{MoveIt 2} y el paquete \textit{xarm\_planner}, integrados en el repositorio
oficial \cite{xarm_ros2}. Este planificador permite definir trayectorias en espacio articular 
y cartesiano, que son posteriormente ejecutadas en tiempo real a través de \textit{ros2\_control}
\cite{ros2_control}. \\

Los tipos de trayectorias que se pueden generar son \cite{barrientos2007fundamentos}: lineales y circulares en espacio cartesiano, 
polinómicas en espacio articular y multipunto (\textit{multi-waypoint}). \\

\subsubsection{\textbf{Trayectorias lineales en espacio cartesiano}} 
    el efector final se desplaza siguiendo una línea recta entre dos poses definidas. 
    Matemáticamente,
\[
    x(t) = x_0 + \frac{t}{T}\,(x_f - x_0), \qquad t \in [0,T],
    \]
    con condiciones de contorno
\[
    x(0) = x_0, \qquad x(T) = x_f.
    \]
    Aunque la interpolación cartesiana es lineal, \textit{MoveIt} aplica una 
    parametrización temporal que suaviza la velocidad y 
    aceleración, evitando discontinuidades. En particular, se emplea el algoritmo 
    \textit{Iterative Parabolic Time Parameterization (IPTP)}, que ajusta los perfiles de 
    velocidad y aceleración de cada articulación para cumplir los límites dinámicos del robot. \\

\subsubsection{\textbf{Trayectorias circulares en espacio cartesiano}}
    se definen mediante un arco de circunferencia, especificando centro $c$, radio $r$ y ángulo 
    barrido $\theta(t)$:
\[
    x(t) = c + r \begin{bmatrix}
        \cos \theta(t) \\ \sin \theta(t) \\ 0
    \end{bmatrix}, \qquad 
    \theta(t) = \theta_0 + \frac{t}{T}(\theta_f - \theta_0).
    \]

    Estas trayectorias se utilizan para movimientos de arco, por ejemplo en operaciones de 
    pulido o soldadura. En este caso, también pueden aparecer discontinuidades en la velocidad
    y aceleración, siendo necesario aplicar el algoritmo \textit{IPTP}. \\


\subsubsection{Corrección de discontinuidades mediante \textit{IPTP}}
El procedimiento consiste en recorrer iterativamente la trayectoria 
    planificada y asignar tiempos de paso a cada segmento de manera que:
\[
\dot{q}_i(t) \leq \dot{q}_{i,\text{max}}, 
\qquad 
\ddot{q}_i(t) \leq \ddot{q}_{i,\text{max}},
\]
para todas las articulaciones \(i\), garantizando que las velocidades y aceleraciones nunca 
superen los valores máximos permitidos. \\

El algoritmo \textit{IPTP} utiliza perfiles de velocidad parabólicos para cada segmento, de modo que 
la aceleración se mantiene constante dentro de cada tramo y se ajusta en los puntos de unión 
para asegurar continuidad. Esto permite que las trayectorias lineales o circulares en espacio 
cartesiano se conviertan en trayectorias articulares suaves y físicamente realizables. \\

Para ilustrar el problema, supóngase una trayectoria lineal cartesiana definida por dos 
segmentos consecutivos en el espacio articular de una sola articulación \(q(t)\):
\[
q(t) = 
\begin{cases}
q_0 + \dfrac{t}{T_1}(q_1 - q_0), & t \in [0, T_1], \\
q_1 + \dfrac{t-T_1}{T_2}(q_2 - q_1), & t \in [T_1, T_1+T_2].
\end{cases}
\]

Las condiciones de contorno son:
\[
q(0) = q_0, \quad q(T_1) = q_1, \quad q(T_1+T_2) = q_2.
\]

La velocidad resultante en cada tramo es constante:
\[
\dot{q}(t) = 
\begin{cases}
\dfrac{q_1 - q_0}{T_1}, & t \in [0, T_1], \\
\dfrac{q_2 - q_1}{T_2}, & t \in [T_1, T_1+T_2].
\end{cases}
\]

Esto implica una discontinuidad en la velocidad en el punto de unión \(t = T_1\), ya que:
\[
\dot{q}(T_1^-) = \dfrac{q_1 - q_0}{T_1}
\quad \neq \quad
\dot{q}(T_1^+) = \dfrac{q_2 - q_1}{T_2}.
\]

Si los valores difieren, se produce un salto brusco en la velocidad, y por tanto una 
aceleración infinita en ese instante:
\[
\ddot{q}(t) = \delta(t-T_1)\,\bigl(\dot{q}(T_1^+) - \dot{q}(T_1^-)\bigr),
\]
donde \(\delta(t-T_1)\) representa la función delta de Dirac, que permite modelar esa variación brusca. \\

El algoritmo \textit{Iterative Parabolic Time Parameterization (IPTP)} corrige este problema 
introduciendo perfiles de velocidad parabólicos en cada segmento. En lugar de mantener 
velocidad constante, se define un perfil con aceleración constante en la fase inicial y 
final de cada tramo y velocidad constante en la fase intermedia:
\[
\dot{q}(t) = 
\begin{cases}
\dot{q}_0 + \ddot{q}\,t, & \text{fase de aceleración}, \\
\dot{q}_{\text{const}}, & \text{fase de velocidad constante}, \\
\dot{q}_{\text{const}} - \ddot{q}\,(t-t_f), & \text{fase de deceleración}.
\end{cases}
\]

De este modo, la aceleración \(\ddot{q}\) se mantiene finita y constante en cada tramo, 
y la velocidad se ajusta suavemente en los puntos de unión, garantizando continuidad:
\[
\dot{q}(T_1^-) = \dot{q}(T_1^+).
\] \\

escalado temporal uniforme + reinterpolación quíntica.

%Aunque la función se denomina iptp_scale_time, no implementa el algoritmo IPTP clásico de Bobrow Shin McKay. En su lugar, aplica un escalado temporal global para garantizar que la trayectoria quíntica cumple los límites de velocidad y aceleración, regenerando una nueva interpolación polinómica con el tiempo ampliado. Este procedimiento es una forma simplificada de Time Optimal Trajectory Generation (TOTG), pero no constituye un retiming diferencial ni una parametrización óptima en el sentido de IPTP.

%El escalado temporal implementado no corresponde al algoritmo IPTP clásico de Bobrow Shin McKay, pero sí se inspira en la misma idea fundamental: ajustar la parametrización temporal de la trayectoria para garantizar el cumplimiento de límites de velocidad y aceleración. En este trabajo se utiliza una versión simplificada basada en un factor global de escalado, en lugar del retiming diferencial forward backward característico de IPTP.

\subsubsection{\textbf{Trayectorias polinómicas en espacio articular}}
Cuando se especifican directamente configuraciones articulares, \textit{MoveIt} genera 
trayectorias suaves mediante interpolación polinómica que garantizan continuidad en posición
y velocidad evitando saltos bruscos. Sin embargo, con el objetivo de asegurar que 
la trayectoria sea físicamente realizable y que se respeten los límites dinámicos del robot, 
es necesario realizar una parametrización temporal mediante el algoritmo 
\textit{Iterative Parabolic Time Parameterization (IPTP)}. \\

Las trayectorias polinómicas más habituales son el polinomio cúbico:
\[
    q_i(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3, \qquad t \in [0,T].
    \]
    con condiciones de contorno en posición y velocidad:
    
\[
    q_i(0) = q_{i,0}, \quad \dot{q}_i(0) = \dot{q}_{i,0}, \quad
    q_i(T) = q_{i,f}, \quad \dot{q}_i(T) = \dot{q}_{i,f}.
    \]

\[a_0 = q_{i,0}, \quad a_1 = \dot{q}_{i,0},\]
\[a_2 = \frac{3\,(q_{i,f} - q_{i,0}) - (2\,\dot{q}_{i,0} + \dot{q}_{i,f})\,T}{T^2},
\quad
a_3 = \frac{2\,(q_{i,0} - q_{i,f}) + (\dot{q}_{i,0} + \dot{q}_{i,f})\,T}{T^3}.\] \\

Y el polinomio quíntico:
\[
q_i(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5, \qquad t \in [0,T].
\]

\[
q_i(0) = q_{i,0}, \quad \dot{q}_i(0) = \dot{q}_{i,0}, \quad \ddot{q}_i(0) = \ddot{q}_{i,0},
\]
\[
q_i(T) = q_{i,f}, \quad \dot{q}_i(T) = \dot{q}_{i,f}, \quad \ddot{q}_i(T) = \ddot{q}_{i,f}.
\]

\[
\begin{aligned}
a_0 &= q_{i,0}, \\ a_1 &= \dot{q}_{i,0}, \\
a_2 &= \tfrac{1}{2}\,\ddot{q}_{i,0}, \\
a_3 &= \frac{20(q_{i,f} - q_{i,0}) - (8\dot{q}_{i,f} + 12\dot{q}_{i,0})T - (3\ddot{q}_{i,0} - \ddot{q}_{i,f})T^2}{2T^3}, \\
a_4 &= \frac{30(q_{i,0} - q_{i,f}) + (14\dot{q}_{i,f} + 16\dot{q}_{i,0})T + (3\ddot{q}_{i,0} - 2\ddot{q}_{i,f})T^2}{2T^4}, \\
a_5 &= \frac{12(q_{i,f} - q_{i,0}) - (6\dot{q}_{i,f} + 6\dot{q}_{i,0})T - (\ddot{q}_{i,0} - \ddot{q}_{i,f})T^2}{2T^5}.
\end{aligned}
\] \\

\subsubsection{\textbf{Trayectorias \textit{spline} (\textit{multi-waypoint})}}
Cuando se definen múltiples puntos intermedios en espacio cartesiano, \textit{MoveIt} 
interpola mediante \textit{splines} cúbicos, asegurando continuidad en posición y velocidad a lo 
largo de toda la trayectoria. Sin embargo, esta interpolación geométrica 
no garantiza por sí sola que se respeten los límites dinámicos del robot. Por ello, el 
algoritmo de parametrización temporal \textit{Iterative Spline Parameterization (ISP)} 
ajusta los tiempos de paso de cada segmento para evitar oscilaciones y asegurar un 
movimiento fluido y físicamente realizable. \\

Un \textit{spline} cúbico se define en cada intervalo $[t_k, t_{k+1}]$ como:
\[
q_i(t) = b_0 + b_1 (t-t_k) + b_2 (t-t_k)^2 + b_3 (t-t_k)^3,
\]
donde los coeficientes $b_j$ se calculan imponiendo continuidad en posición, velocidad y 
aceleración en los puntos de unión:
\[
q_i(t_k^-) = q_i(t_k^+), \quad 
\dot{q}_i(t_k^-) = \dot{q}_i(t_k^+), \quad 
\ddot{q}_i(t_k^-) = \ddot{q}_i(t_k^+).
\]

\[
q_i(t_k) = q_{i,k}, \quad \dot{q}_i(t_k) = v_{i,k}, \quad
q_i(t_{k+1}) = q_{i,k+1}, \quad \dot{q}_i(t_{k+1}) = v_{i,k+1}.
\]

\[
\begin{aligned}
b_0 &= q_{i,k}, \\
b_1 &= v_{i,k}, \\
b_2 &= \frac{3(q_{i,k+1} - q_{i,k})}{h^2} - \frac{2v_{i,k} + v_{i,k+1}}{h}, \\
b_3 &= \frac{2(q_{i,k} - q_{i,k+1})}{h^3} + \frac{v_{i,k} + v_{i,k+1}}{h^2},
\end{aligned}
\]
donde $h = t_{k+1} - t_k$ es la duración del intervalo. De este modo, la trayectoria completa es continua en posición, velocidad y aceleración, 
evitando saltos bruscos y oscilaciones no deseadas. El algoritmo \textit{ISP} recorre iterativamente 
todos los segmentos y ajusta los tiempos de paso para cumplir los límites dinámicos del robot:
\[
\dot{q}_i(t) \leq \dot{q}_{i,\text{max}}, 
\qquad 
\ddot{q}_i(t) \leq \ddot{q}_{i,\text{max}}.
\]

Cabe destacar que los coeficientes $b_j$ en cada intervalo se obtienen a partir de las 
condiciones de posición y velocidad en los extremos, mientras que la continuidad en 
aceleración se garantiza al resolver el sistema \textit{spline} completo para todos los
\textit{waypoints} o puntos de paso.\\

\subsection{Cálculo de la trayectoria en \textit{Matlab} con la \textit{toolbox} de Peter Corke}
Se ha programado una trayectoria articular quíntica para el robot en estudio, garantizando 
que las posiciones obtenidas en durante la trayectoria son realizables. Es importante 
tener en cuenta que previo al cálculo de esta trayectoria es necesario obtener las posiciones 
articulares finales deseadas mediante cinemática inversa. \\

Las imágenes \ref{fig:traj} y \ref{fig:traj2} muestran la trayectoria calculada mediante el código 
\ref{lst:traj} para las posiciones indicadas en el código \ref{lst:traj_salida}. \\

\lstinputlisting[
    caption={Generación de trayectoria articular realizable.},
    label={lst:traj},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/traj.m}
\lstinputlisting[
    caption={Salida de la generación de trayectoria articular realizable.},
    label={lst:traj_salida},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/traj_salida.m}

\clearpage
\vfill
\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.9]{Images/cinematica/traj.png}
    \caption{Trayectoria articular realizable.}
    \label{fig:traj}
\end{figure}
\vfill
\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.9]{Images/cinematica/traj2.png}
    \caption{Trayectoria realizable del efector.}
    \label{fig:traj2}
\end{figure}
\vfill

\clearpage
\subsection{Control cinemático}
Para llevar a cabo el control cinemático del brazo robótico es necesario combinar todo el estudio
cinemático presentado, tal que los pasos a seguir son:

\begin{enumerate}
    \item Calcular la cinemática directa.
    \item Calcular la cinemática diferencial.
    \item Calcular la cinemática inversa.
    \item Generar las trayectorias de movimiento.
\end{enumerate}

En este sentido, se ha programado en \textit{Matlab}, junto con la \textit{toolbox} de Peter Corke, 
el control cinemático completo del robot \textit{UFactory xArm6}. Al inicio, el programa solicita 
la posición articular de origen, dado que el robot conoce con exactitud las posiciones de sus 
articulaciones; la posición cartesiana a alcanzar, ya que es de interés del usuario mover el 
robot a una posición cartesiana, y la duración en segundos de la trayectoria. La aplicación comprueba 
que la posición final es alcanzable según el rango de trabajo del robot de $700$ mm, calcula las posiciones,
velocidades y aceleraciones articulares necesarias para alcanzar la posición cartesiana final mediante 
cinemática inversa y genera la trayectoria correspondiente. \\

Las imágenes \ref{fig:cin_control}, \ref{fig:cin_control2}, \ref{fig:cin_control_v_art}, 
\ref{fig:cin_control_v_cart}, \ref{fig:cin_control_a_art} y \ref{fig:cin_control_vcart}
muestran la trayectoria articular y del efector y las velocidades y aceleraciones 
articulares y cartesianas, y los códigos \ref{lst:cin_control} y \ref{lst:cin_control2} la implementación y la salida por terminal. \\

\vspace{1.3cm}
\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.9]{Images/cinematica/cin_control.png}
    \caption{Trayectoria articular realizable.}
    \label{fig:cin_control}
\end{figure}
\clearpage
\vfill
\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.9]{Images/cinematica/cin_control2.png}
    \caption{Trayectoria realizable del efector.}
    \label{fig:cin_control2}
\end{figure}
\vfill
\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.9]{Images/cinematica/cin_control_v_cart.png}
    \caption{Velocidad cartesiana del efector.}
    \label{fig:cin_control_v_art}
\end{figure}
\vfill
\clearpage
\vfill
\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.9]{Images/cinematica/cin_control_v_art.png}
    \caption{Velocidades articulares.}
    \label{fig:cin_control_v_cart}
\end{figure}
\vfill
\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.9]{Images/cinematica/cin_control_a_cart.png}
    \caption{Aceleración cartesiana del efector.}
    \label{fig:cin_control_a_art}
\end{figure}
\vfill
\clearpage
\begin{figure}[htb]
    \centering
    \includegraphics[scale=0.9]{Images/cinematica/cin_control_a_art.png}
    \caption{Aceleraciones articulares.}
    \label{fig:cin_control_vcart}
\end{figure}

\lstinputlisting[
    caption={Control cinemático completo.},
    label={lst:cin_control},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/cin_control.m}
\lstinputlisting[
    caption={Salida del control cinemático completo.},
    label={lst:cin_control2},
    breaklines=true,
    breakatwhitespace=true
]{Matlab/cin_control_salida.m}

