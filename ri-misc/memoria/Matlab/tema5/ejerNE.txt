clear; clc;
syms L1 q1 q2 q1d q2d q1dd q2dd g m1 m2 real

% Eslabón 1: revoluta, marco en la articulación, COM a L1/2 en x
L1_link = Revolute('d', 0, 'a', 0, 'alpha', 0, ...
                   'm', m1, 'r', [L1/2 0 0], 'I', [0 0 0 0 0 0]);

% Eslabón 2: prismática, COM a q2/2 en z
L2_link = Prismatic('theta', 0, 'a', 0, 'alpha', -pi/2, ...
                    'm', m2, 'r', [0 0 q2/2], 'I', [0 0 0 0 0 0]);

% Robot en serie
robot = SerialLink([L1_link, L2_link], 'name', 'RP');
robot.gravity = [0 0 -g];

% Estados articulares (nota: la toolbox no admite COM dependiente de q,
% saldrá una fracción racional muy grande como resultado,
% la toolbox está pensada para evalua numéricamente).
q   = [q1, q2];
qd  = [q1d, q2d];
qdd = [q1dd, q2dd];

% Dinámica
M   = robot.inertia(q);
G   = robot.gravload(q);
tau = robot.rne(q, qd, qdd);

disp('--- Matriz de inercia D(q) ---');
pretty(M)
disp('--- Vector de gravedad G(q) ---');
pretty(G)
disp('--- Pares articulares tau ---');
pretty(simplify(tau))

