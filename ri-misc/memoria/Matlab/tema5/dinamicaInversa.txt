clear; clc;
syms L1 q1 q2 g m1 m2 real
syms Ixx1 Iyy1 Izz1 Ixy1 Ixz1 Iyz1
syms Ixx2 Iyy2 Izz2 Ixy2 Ixz2 Iyz2

% Eslabón 1: rotacional
L1_link = Revolute('d', 0, 'a', 0, 'alpha', 0, ...
                   'm', m1, 'r', [L1/2 0 0], ...
                   'I', [Ixx1 Iyy1 Izz1 Ixy1 Ixz1 Iyz1]);

% Eslabón 2: prismático
L2_link = Prismatic('theta', 0, 'a', 0, 'alpha', -pi/2, ...
                    'm', m2, 'r', [0 0 q2/2], ...
                    'I', [Ixx2 Iyy2 Izz2 Ixy2 Ixz2 Iyz2]);

% Robot en serie
robot = SerialLink([L1_link, L2_link], 'name', 'RP');
robot.gravity = [0 0 -g];

% Estados articulares
q   = [q1, q2];        % posiciones
qd  = [0, 0];          % velocidades (ambas en cero)
qdd = [1, 0];          % aceleración: 1 rad/s² en q1, 0 en q2

% Dinámica inversa: torques/fuerzas requeridos
tau = robot.rne(q, qd, qdd);

disp('--- Pares articulares requeridos ---');
pretty(simplify(tau));

% Si quieres solo el torque del primer eslabón:
tau1 = simplify(tau(1));
disp('--- Torque en la articulación 1 ---');
pretty(tau1)

